#include <type_traits>
#include <memory>
#include <vector>
#include <limits>

#include "cxxtest/TestSuite.h"
#include "bbmp/bbmp.h"

#ifndef SCHEMAS_DIR
#define SCHEMAS_DIR "."
#endif

class IntTestSuite : public CxxTest::TestSuite
{
public:
    void setUp();
    void test1();
private:
    using ProtocolPtr = std::unique_ptr<bbmp::Protocol>;
    using ErrLevelList = std::vector<bbmp::ErrorLevel>;
    ProtocolPtr prepareProtocol(const std::string& schema);

    struct TestStatus
    {
        ErrLevelList m_expErrors;
        bool m_expParseResult = true;
        bool m_expValidateResult = true;
    };

    TestStatus m_status;
};

void IntTestSuite::setUp()
{
    m_status = TestStatus();
}

void IntTestSuite::test1()
{
    auto protocol = prepareProtocol(SCHEMAS_DIR "/Schema1.xml");
    TS_ASSERT(protocol);
    auto& namespaces = protocol->namespaces();
    TS_ASSERT_EQUALS(namespaces.size(), 1U);

    auto& ns = namespaces.front();
    TS_ASSERT(ns.name().empty());

    auto& fields = ns.fields();
    TS_ASSERT_EQUALS(fields.size(), 1U);

    auto& field = fields.front();
    TS_ASSERT_EQUALS(field.name(), "Int1");
    TS_ASSERT(field.displayName().empty());
    TS_ASSERT(field.description().empty());
    TS_ASSERT_EQUALS(field.kind(), bbmp::Field::Kind::Int);

    bbmp::IntField intField(field);
    auto scaling = intField.scaling();
    auto& validRanges = intField.validRanges();
    auto& specialValues = intField.specialValues();
    TS_ASSERT_EQUALS(intField.type(), bbmp::IntField::Type::Uint8);
    TS_ASSERT_EQUALS(intField.endian(), bbmp::Endian_Big);
    TS_ASSERT_EQUALS(intField.length(), 1U);
    TS_ASSERT_EQUALS(intField.bitLength(), 8U);
    TS_ASSERT_EQUALS(intField.serOffset(), 0);
    TS_ASSERT_EQUALS(intField.minValue(), 0);
    TS_ASSERT_EQUALS(intField.maxValue(), (std::intmax_t)std::numeric_limits<std::uint8_t>::max());
    TS_ASSERT_EQUALS(intField.defaultValue(), 0);
    TS_ASSERT_EQUALS(scaling.first, 1);
    TS_ASSERT_EQUALS(scaling.second, 1);
    TS_ASSERT(validRanges.empty());
    TS_ASSERT(specialValues.empty());
}

IntTestSuite::ProtocolPtr IntTestSuite::prepareProtocol(const std::string& schema)
{
    static_cast<void>(schema);
    ProtocolPtr protocol(new bbmp::Protocol);
    protocol->setErrorReportCallback(
        [this](bbmp::ErrorLevel level, const std::string& msg)
        {
            static const std::string LevelMap[] = {
                "[DEBUG]: ",
                "[INFO]: ",
                "[WARNING]: ",
                "[ERROR]: "
            };
            static const std::size_t LevelMapSize =
                    std::extent<decltype(LevelMap)>::value;

            static_assert(LevelMapSize == bbmp::ErrorLevel_NumOfValues, "Invalid Map");

            if ((level < static_cast<decltype(level)>(0)) ||
                (bbmp::ErrorLevel_NumOfValues <= level)) {
                level = bbmp::ErrorLevel_Error;
            }

            auto errMsg = LevelMap[level] + msg;
            TS_TRACE(errMsg);

            if (m_status.m_expErrors.empty()) {
                TS_ASSERT(level < bbmp::ErrorLevel_Error);
                return;
            }

            if (level < bbmp::ErrorLevel_Warning) {
                return;
            }

            TS_ASSERT_EQUALS(level, m_status.m_expErrors.front());
            m_status.m_expErrors.erase(m_status.m_expErrors.begin());
        });

    bool parseResult = protocol->parse(schema);
    TS_ASSERT_EQUALS(parseResult, m_status.m_expParseResult);

    bool validateResult = protocol->validate();
    TS_ASSERT_EQUALS(validateResult, m_status.m_expValidateResult);
    return protocol;
}
